<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neural Background - Screen Recorder</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #000; overflow: hidden; font-family: system-ui, sans-serif; }
    canvas { position: fixed; inset: 0; width: 100vw; height: 100vh; }
    .controls {
      position: fixed; top: 20px; right: 20px;
      background: rgba(0,0,0,0.8); padding: 20px; border-radius: 12px;
      color: white; z-index: 100; min-width: 200px;
      backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1);
    }
    .controls h3 { margin-bottom: 15px; font-size: 14px; opacity: 0.7; }
    .control-group { margin-bottom: 12px; }
    .control-group label { display: block; font-size: 12px; margin-bottom: 4px; opacity: 0.6; }
    .control-group input[type="range"] { width: 100%; }
    .presets { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 15px; }
    .preset {
      padding: 6px 12px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.1); color: white; cursor: pointer; font-size: 12px;
    }
    .preset:hover { background: rgba(255,255,255,0.2); }
    .hide-btn {
      margin-top: 15px; width: 100%; padding: 8px;
      background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px; color: white; cursor: pointer;
    }
    .show-btn {
      position: fixed; top: 20px; right: 20px; padding: 10px 16px;
      background: rgba(0,0,0,0.6); border: 1px solid rgba(255,255,255,0.2);
      border-radius: 8px; color: white; cursor: pointer; z-index: 100; display: none;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div class="controls" id="controls">
    <h3>NEURAL BACKGROUND</h3>
    <div class="control-group">
      <label>Hue: <span id="hueVal">200</span>Â°</label>
      <input type="range" id="hue" min="0" max="360" value="200">
    </div>
    <div class="control-group">
      <label>Saturation: <span id="satVal">0.8</span></label>
      <input type="range" id="saturation" min="0" max="100" value="80">
    </div>
    <div class="control-group">
      <label>Chroma: <span id="chromaVal">0.6</span></label>
      <input type="range" id="chroma" min="0" max="100" value="60">
    </div>
    <div class="presets">
      <button class="preset" data-hue="200" data-sat="80" data-chroma="60">Blue</button>
      <button class="preset" data-hue="280" data-sat="70" data-chroma="50">Purple</button>
      <button class="preset" data-hue="340" data-sat="80" data-chroma="55">Pink</button>
      <button class="preset" data-hue="160" data-sat="70" data-chroma="50">Cyan</button>
      <button class="preset" data-hue="30" data-sat="80" data-chroma="60">Orange</button>
      <button class="preset" data-hue="120" data-sat="60" data-chroma="45">Green</button>
    </div>
    <button class="hide-btn" id="hideBtn">Hide Controls (for recording)</button>
  </div>
  <button class="show-btn" id="showBtn">Show Controls</button>

  <script>
    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

    let settings = { hue: 200, saturation: 0.8, chroma: 0.6 };
    let pointer = { x: 0.5, y: 0.5, tX: 0.5, tY: 0.5 };

    const vertexShader = `
      attribute vec2 position;
      varying vec2 vUv;
      void main() {
        vUv = position * 0.5 + 0.5;
        gl_Position = vec4(position, 0.0, 1.0);
      }
    `;

    const fragmentShader = `
      precision highp float;
      varying vec2 vUv;
      uniform float u_time;
      uniform float u_ratio;
      uniform vec2 u_pointer;
      uniform float u_hue;
      uniform float u_saturation;
      uniform float u_chroma;

      vec2 rotate(vec2 uv, float th) {
        return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;
      }

      float neuro_shape(vec2 uv, float t, float p) {
        vec2 sine_acc = vec2(0.);
        vec2 res = vec2(0.);
        float scale = 8.;
        for (int j = 0; j < 15; j++) {
          uv = rotate(uv, 1.);
          sine_acc = rotate(sine_acc, 1.);
          vec2 layer = uv * scale + float(j) + sine_acc - t;
          sine_acc += sin(layer) + 2.4 * p;
          res += (.5 + .5 * cos(layer)) / scale;
          scale *= 1.2;
        }
        return res.x + res.y;
      }

      vec3 hsl2rgb(vec3 c) {
        vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);
        return c.z + c.y * (rgb - 0.5) * (1.0 - abs(2.0 * c.z - 1.0));
      }

      void main() {
        vec2 uv = vUv * 0.5;
        uv.x *= u_ratio;

        vec2 pointerDelta = vUv - u_pointer;
        pointerDelta.x *= u_ratio;
        float p = clamp(length(pointerDelta), 0., 1.);
        p = .5 * pow(1. - p, 2.);

        float t = .001 * u_time;
        float noise = neuro_shape(uv, t, p);
        noise = 1.2 * pow(noise, 3.);
        noise += pow(noise, 10.);
        noise = max(.0, noise - .5);
        noise *= (1. - length(vUv - .5));

        float normalizedHue = u_hue / 360.0;
        vec3 hsl = vec3(normalizedHue, u_saturation, u_chroma * 0.5 + 0.1);
        vec3 color = hsl2rgb(hsl) * noise;

        gl_FragColor = vec4(color, 1.0);
      }
    `;

    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Shader error:', gl.getShaderInfoLog(shader));
        return null;
      }
      return shader;
    }

    function createProgram(gl, vs, fs) {
      const program = gl.createProgram();
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Program error:', gl.getProgramInfoLog(program));
        return null;
      }
      return program;
    }

    const vs = createShader(gl, gl.VERTEX_SHADER, vertexShader);
    const fs = createShader(gl, gl.FRAGMENT_SHADER, fragmentShader);
    const program = createProgram(gl, vs, fs);

    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);

    const positionLoc = gl.getAttribLocation(program, 'position');
    const timeLoc = gl.getUniformLocation(program, 'u_time');
    const ratioLoc = gl.getUniformLocation(program, 'u_ratio');
    const pointerLoc = gl.getUniformLocation(program, 'u_pointer');
    const hueLoc = gl.getUniformLocation(program, 'u_hue');
    const satLoc = gl.getUniformLocation(program, 'u_saturation');
    const chromaLoc = gl.getUniformLocation(program, 'u_chroma');

    function resize() {
      canvas.width = window.innerWidth * devicePixelRatio;
      canvas.height = window.innerHeight * devicePixelRatio;
      gl.viewport(0, 0, canvas.width, canvas.height);
    }

    function render(time) {
      pointer.x += (pointer.tX - pointer.x) * 0.1;
      pointer.y += (pointer.tY - pointer.y) * 0.1;

      gl.useProgram(program);
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.enableVertexAttribArray(positionLoc);
      gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

      gl.uniform1f(timeLoc, time);
      gl.uniform1f(ratioLoc, canvas.width / canvas.height);
      gl.uniform2f(pointerLoc, pointer.x, pointer.y);
      gl.uniform1f(hueLoc, settings.hue);
      gl.uniform1f(satLoc, settings.saturation);
      gl.uniform1f(chromaLoc, settings.chroma);

      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      requestAnimationFrame(render);
    }

    window.addEventListener('resize', resize);
    window.addEventListener('pointermove', e => {
      pointer.tX = e.clientX / window.innerWidth;
      pointer.tY = 1 - e.clientY / window.innerHeight;
    });

    // Controls
    document.getElementById('hue').oninput = e => {
      settings.hue = +e.target.value;
      document.getElementById('hueVal').textContent = settings.hue;
    };
    document.getElementById('saturation').oninput = e => {
      settings.saturation = +e.target.value / 100;
      document.getElementById('satVal').textContent = settings.saturation.toFixed(2);
    };
    document.getElementById('chroma').oninput = e => {
      settings.chroma = +e.target.value / 100;
      document.getElementById('chromaVal').textContent = settings.chroma.toFixed(2);
    };

    document.querySelectorAll('.preset').forEach(btn => {
      btn.onclick = () => {
        settings.hue = +btn.dataset.hue;
        settings.saturation = +btn.dataset.sat / 100;
        settings.chroma = +btn.dataset.chroma / 100;
        document.getElementById('hue').value = settings.hue;
        document.getElementById('saturation').value = settings.saturation * 100;
        document.getElementById('chroma').value = settings.chroma * 100;
        document.getElementById('hueVal').textContent = settings.hue;
        document.getElementById('satVal').textContent = settings.saturation.toFixed(2);
        document.getElementById('chromaVal').textContent = settings.chroma.toFixed(2);
      };
    });

    document.getElementById('hideBtn').onclick = () => {
      document.getElementById('controls').style.display = 'none';
      document.getElementById('showBtn').style.display = 'block';
    };
    document.getElementById('showBtn').onclick = () => {
      document.getElementById('controls').style.display = 'block';
      document.getElementById('showBtn').style.display = 'none';
    };

    resize();
    render(0);
  </script>
</body>
</html>
